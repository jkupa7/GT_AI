
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###͏︍͏︆͏󠄁
#################################################
# file to edit: notebook.ipynb͏︍͏︆͏󠄁

import time
from isolation import Board

# Credits if any͏︍͏︆͏󠄁
# 1)͏︍͏︆͏󠄁
# 2)͏︍͏︆͏󠄁
# 3)͏︍͏︆͏󠄁

class OpenMoveEvalFn:
    def score(self, game, my_player=None):
        """Score the current game state
        Evaluation function that outputs a score equal to how many
        moves are open for AI player on the board minus how many moves
        are open for Opponent's player on the board.

        Note:
            If you think of better evaluation function, do it in CustomEvalFn below.

            Args
                game (Board): The board and game state.
                my_player (Player object): This specifies which player you are.

            Returns:
                float: The current state's score. MyMoves-OppMoves.

            """

        # TODO: finish this function!͏︍͏︆͏󠄁
        my_moves = game.get_player_moves(my_player)
        opp_moves = game.get_opponent_moves(my_player)
        #print(my_moves)
        #print(opp_moves)
        return len(my_moves) - len(opp_moves)


        raise NotImplementedError


######################################################################
########## DON'T WRITE ANY CODE OUTSIDE THE FUNCTION! ################͏︍͏︆͏󠄁
######## IF YOU WANT TO CALL OR TEST IT CREATE A NEW CELL ############͏︍͏︆͏󠄁
######################################################################
##### CODE BELOW IS USED FOR RUNNING LOCAL TEST DON'T MODIFY IT ######͏︍͏︆͏󠄁
################ END OF LOCAL TEST CODE SECTION ######################͏︍͏︆͏󠄁

class CustomPlayer:
    # TODO: finish this class!͏︍͏︆͏󠄁
    """Player that chooses a move using your evaluation function
    and a minimax algorithm with alpha-beta pruning.
    You must finish and test this player to make sure it properly
    uses minimax and alpha-beta to return a good move."""

    def __init__(self, search_depth=3, eval_fn=OpenMoveEvalFn()):
        """Initializes your player.

        if you find yourself with a superior eval function, update the default
        value of `eval_fn` to `CustomEvalFn()`

        Args:
            search_depth (int): The depth to which your agent will search
            eval_fn (function): Evaluation function used by your agent
        """
        self.eval_fn = eval_fn
        self.search_depth = search_depth

    def move(self, game, time_left):
        """Called to determine one move by your agent

        Note:
            1. Do NOT change the name of this 'move' function. We are going to call
            this function directly.
            2. Call alphabeta instead of minimax once implemented.
        Args:
            game (Board): The board and game state.
            time_left (function): Used to determine time left before timeout

        Returns:
            tuple: (int,int): Your best move
        """

        best_move, utility = alphabeta(self, game, time_left, depth=self.search_depth)
        #def alphabeta(player, game, time_left, depth, alpha=float("-inf"), beta=float("inf"), my_turn=True):

        return best_move



    def utility(self, game, my_turn):
        """You can handle special cases here (e.g. endgame)"""

        return self.eval_fn.score(game, self)



###################################################################
########## DON'T WRITE ANY CODE OUTSIDE THE CLASS! ################͏︍͏︆͏󠄁
###### IF YOU WANT TO CALL OR TEST IT CREATE A NEW CELL ###########͏︍͏︆͏󠄁
###################################################################


def minimax(player, game, time_left, depth, my_turn=True):
    """Implementation of the minimax algorithm.
    Args:
        player (CustomPlayer): This is the instantiation of CustomPlayer()
            that represents your agent. It is used to call anything you
            need from the CustomPlayer class (the utility() method, for example,
            or any class variables that belong to CustomPlayer()).
        game (Board): A board and game state.
        time_left (function): Used to determine time left before timeout
        depth: Used to track how deep you are in the search tree
        my_turn (bool): True if you are computing scores during your turn.

    Returns:
        (tuple, int): best_move, val
    """

    # TODO: finish this function!͏︍͏︆͏󠄁

    best_move = None
    utility = None


    for d in range(1, depth+1):
        if (time_left()) <= 0:
            break
        candidate_best_move, candidate_utility = max_player(game, time_left, d)

        if (time_left() ) > 0 and candidate_best_move != None:
            best_move = candidate_best_move
            utility = candidate_utility
        else:
            break
        print("Depth: ", d, "Best move: ", best_move, "Utility: ", utility)

    #print(f"Best move: {best_move}")
    return (best_move, utility)

def max_player(game, time_left, depth_left):

    best_move = (None, None, None)
    v = float('-inf')

    valid_moves = get_valid_moves(game, game.get_active_player())

    heu = heuristic(game, game.get_active_player())


    if is_cutoff(time_left, depth_left):

        return None, heu

    game_over, winner = is_terminal(game, game.get_active_player())
    if game_over:
        if winner == None:
            return None, 1/2
        else:
            return None, 0


    for cur_move in valid_moves:
        if (time_left()) <= 0:
            break

        new_gameboard, game_over, winner = game.forecast_move(cur_move)
        new_move, new_v = min_player(new_gameboard, time_left, depth_left-1)
        if new_v > v:
            v = new_v
            best_move = cur_move

    return best_move, v

def min_player(game, time_left, depth_left):
    best_move = (None, None, None)
    v = float('inf')

    valid_moves = get_valid_moves(game, game.get_active_player())

    heu = heuristic(game, game.get_inactive_player())

    if is_cutoff(time_left, depth_left):

        return None, heu

    game_over, winner = is_terminal(game, game.get_active_player())
    if game_over:
        if winner == None:
            return None, 1/2
        else:
            return None, 1

    for cur_move in valid_moves:
        if (time_left()) <= 0:
            break

        new_gameboard, game_over, winner = game.forecast_move(cur_move)
        new_move, new_v = max_player(new_gameboard, time_left, depth_left-1)
        if new_v < v:
            v = new_v
            best_move = cur_move

    return best_move, v

def is_cutoff(time_left, depth_left):
    no_time = time_left() <= 0
    no_depth = depth_left <= 0

    if no_time or no_depth:
        return True
    return False

def is_terminal(game, player):

    pm = game.get_player_moves(player)
    om = game.get_opponent_moves(player)

    if len(om) == 0 and len(pm) == 0:
        return True, None
    if len(pm) == 0:
        return True, True
    return False, None


def heuristic(game, player):
    player_moves = game.get_player_moves(player)
    opponent_moves = game.get_opponent_moves(player)
    #print(f"Player moves: {len(player_moves)} -- Opponent moves: {len(opponent_moves)}")
    return len(player_moves) - len(opponent_moves)




def get_valid_moves(game, player):
    return game.get_player_moves(player)


    raise NotImplementedError

######################################################################
########## DON'T WRITE ANY CODE OUTSIDE THE FUNCTION! ################͏︍͏︆͏󠄁
######## IF YOU WANT TO CALL OR TEST IT CREATE A NEW CELL ############͏︍͏︆͏󠄁
######################################################################
##### CODE BELOW IS USED FOR RUNNING LOCAL TEST DON'T MODIFY IT ######͏︍͏︆͏󠄁
################ END OF LOCAL TEST CODE SECTION ######################͏︍͏︆͏󠄁

transposition_table = {}
prune_moves = {}
#killer moves, moves that score high on the heuristic

def alphabeta(player, game, time_left, depth, alpha=float("-inf"), beta=float("inf"), my_turn=True):
    """Implementation of the alphabeta algorithm.

    Args:
        player (CustomPlayer): This is the instantiation of CustomPlayer()
            that represents your agent. It is used to call anything you need
            from the CustomPlayer class (the utility() method, for example,
            or any class variables that belong to CustomPlayer())
        game (Board): A board and game state.
        time_left (function): Used to determine time left before timeout
        depth: Used to track how deep you are in the search tree
        alpha (float): Alpha value for pruning
        beta (float): Beta value for pruning
        my_turn (bool): True if you are computing scores during your turn.

    Returns:
        (tuple, int): best_move, val
    """

    # TODO: finish this function!͏︍͏︆͏󠄁
    global transposition_table
    #transposition_table = {}
    global prune_moves
    #prune_moves = {}

    best_move = (None, None, None)
    utility = float('-inf')

    for d in range(1, depth+1):
        if (time_left()) <= 0:
            break
        candidate_best_move, candidate_utility, _, _ = max_player(game, time_left, d, alpha, beta)
        #candidate_best_move, candidate_utility, _, _ = candidate_struct
        if (time_left() ) > 0 and candidate_best_move != None:
            best_move = candidate_best_move
            utility = candidate_utility
        else:
            break
        #print("Depth: ", d, "Best move: ", best_move, "Utility: ", utility)
    #print(f"GET BOARD: {len(game.get_state())}")

    return (best_move, utility)


    raise NotImplementedError


def max_player(game, time_left, depth_left, alpha, beta):
    global transposition_table
    global prune_moves

    key = (game.copy(), depth_left, 'MAX')
    if key in transposition_table:
        return transposition_table[key]

    # reflect_key = get_reflect_board_key(game, depth_left, 'MAX')
    # if key in transposition_table:
    #     return transposition_table[reflect_key]

    best_move = [None, None, float('-inf'), float('inf')]
    v = float('-inf')

    valid_moves = get_valid_moves(game, game.get_active_player())

    if depth_left in prune_moves:
        prune_list = []
        reg_list = []
        for move in valid_moves:
            if move in prune_moves[depth_left]:
               prune_list.append(move)
            else:
               reg_list.append(move)
        prune_sorted = sort_list(game, prune_list, True)
        reg_sorted = sort_list(game, reg_list, True)
        valid_moves = prune_sorted + reg_sorted

    heu = heuristic(game, game.get_active_player())

    if is_cutoff(time_left, depth_left):
        best_move[0] = None
        best_move[1] = heu
        transposition_table[key] = best_move
        # transposition_table[reflect_key] = best_move
        return best_move

    game_over, winner = is_terminal(game, game.get_active_player())
    if game_over:
        if winner == None:
            best_move[0] = None
            best_move[1] = 1/2

            #return None, 1/2
        else:
            best_move[0] = None
            best_move[1] = 0
        transposition_table[key] = best_move
        # transposition_table[reflect_key] = best_move
        return best_move

    for cur_move in valid_moves:
        if (time_left()) <= 0:
            break

        prev = v

        new_gameboard, game_over, winner = game.forecast_move(cur_move)
        v = max(v, min_player(new_gameboard, time_left, depth_left-1, alpha, beta)[1])
        if v > prev:
            best_move[0] = cur_move
            best_move[1] = v

        alpha = max(alpha, v)
        best_move[2] = alpha

        if beta <= alpha:
            if depth_left not in prune_moves:
                prune_moves[depth_left] = set()
            prune_moves[depth_left].add(cur_move)
            transposition_table[key] = best_move
            # transposition_table[reflect_key] = best_move

            return best_move

    transposition_table[key] = best_move
    # transposition_table[reflect_key] = best_move
    return best_move

def min_player(game, time_left, depth_left, alpha, beta):
    global transposition_table
    global prune_moves

    key = (game.copy(), depth_left, 'MIN')
    if key in transposition_table:
        return transposition_table[key]

    # reflect_key = get_reflect_board_key(game, depth_left, 'MIN')
    # if key in transposition_table:
    #     return transposition_table[reflect_key]

    best_move = [None, None, float('-inf'), float('inf')]
    v = float('inf')

    valid_moves = get_valid_moves(game, game.get_active_player())

    if depth_left in prune_moves:
        prune_list = []
        reg_list = []
        for move in valid_moves:
            if move in prune_moves[depth_left]:
               prune_list.append(move)
            else:
               reg_list.append(move)
        #prune_sorted = sort_list(game, prune_list, False)
        #reg_sorted = sort_list(game, reg_list, False)
        valid_moves = prune_list + reg_list

    heu = heuristic(game, game.get_inactive_player())

    if is_cutoff(time_left, depth_left):
        best_move[0] = None
        best_move[1] = heu
        transposition_table[key] = best_move
        # transposition_table[reflect_key] = best_move
        return best_move

    game_over, winner = is_terminal(game, game.get_active_player())
    if game_over:
        if winner == None:
            best_move[0] = None
            best_move[1] = 1/2

            #return None, 1/2
        else:
            best_move[0] = None
            best_move[1] = 1
        transposition_table[key] = best_move
        # transposition_table[reflect_key] = best_move
        return best_move

    for cur_move in valid_moves:
        if (time_left()) <= 0:
            break

        prev = v

        new_gameboard, game_over, winner = game.forecast_move(cur_move)
        v = min(v, max_player(new_gameboard, time_left, depth_left-1, alpha, beta)[1])
        if v < prev:
            best_move[0] = cur_move
            best_move[1] = v

        beta = min(beta, v)
        best_move[3] = beta

        if beta <= alpha:
            if depth_left not in prune_moves:
                prune_moves[depth_left] = set()
            prune_moves[depth_left].add(cur_move)
            transposition_table[key] = best_move
            # transposition_table[reflect_key] = best_move

            return best_move

    transposition_table[key] = best_move
    # transposition_table[reflect_key] = best_move
    return best_move

def sort_list(game, move_list, is_max):
    sorted_moves = []
    for move in move_list:
        new_board, _, _ = game.forecast_move(move)
        new_heu = heuristic(new_board, new_board.get_active_player())
        sorted_moves.append((new_heu, move))
    sorted_moves.sort(key=lambda x: x[0], reverse=is_max)
    return [move for _, move in sorted_moves]


def board_fullness(game):
    board_len = len(game.get_state())
    fullness = board_len**2
    open_spots = 0
    for row in range(board_len):
        for col in range(board_len):
            if game.is_spot_open(row, col) and not game.is_spot_rook(row, col):
                open_spots += 1
    return (fullness - open_spots) / fullness



def is_cutoff(time_left, depth_left):
    no_time = time_left() <= 0
    no_depth = depth_left <= 0

    if no_time or no_depth:
        return True
    return False

def is_terminal(game, player):
    pm = game.get_player_moves(player)
    om = game.get_opponent_moves(player)

    if len(om) == 0 and len(pm) == 0:
        return True, None
    if len(pm) == 0:
        return True, True
    return False, None

def heuristic(game, player):
    player_pos = game.get_player_position(player)
    opponent_pos = game.get_opponent_position(player)
    player_moves = game.get_player_moves(player)
    opponent_moves = game.get_opponent_moves(player)
    pos_heu = position_heuristic(game, player)
    move_heu = len(player_moves) - len(opponent_moves)
    player_heu = player_separtion_heuristic(game, player)
    opp_heu = opponent_separation_heuristic(game, player)
    #print(f"Player Moves: {len(player_moves)} -- Opponent Moves: {len(opponent_moves)}")
    mobility_heu = mobility_heuristic(game, player)
    board_fullness_heu = board_fullness(game)
    heu = ((1 - board_fullness_heu) * pos_heu) + (board_fullness_heu * move_heu) + (board_fullness_heu * mobility_heu) + ((1-board_fullness_heu) * opp_heu) + ((1-board_fullness_heu) * player_heu)
    #print(f"Player Pos: {player_pos} -- Opponent Pos: {opponent_pos} -- Pos Heu: {pos_heu} -- Move Heu: {move_heu} -- Mobility Heu: {mobility_heu} -- Player Heu: {player_heu} -- Opp Heu: {opp_heu} -- Fullness Heu: {board_fullness_heu} -- Total Heu: {heu}")
    return heu

def player_separtion_heuristic(game, player):
    player_pos = game.get_player_position(player)
    if player_pos == [(-1, -1), (-1, -1)]:
        return 0

    player_score_list = [1,2,3,4,3,2,1]

    if (-1, -1) in player_pos:
        player_pos.remove((-1, -1))
        player_heu = 0
        for (row, col) in player_pos:
            player_heu += player_score_list[row] + player_score_list[col]
        return player_heu**2

    x1, x2, y1, y2 = 0, 0, 0, 0
    for idx, (row, col) in enumerate(player_pos):
        if (row, col) == (-1, -1): continue
        if idx == 0:
            x1, y1 = row, col
        else:
            x2, y2 = row, col

    player_dist = -1 * (abs(x1 - x2) + abs(y1 - y2))

    return player_dist

def opponent_separation_heuristic(game, player):
    opponent_pos = game.get_opponent_position(player)
    if opponent_pos == [(-1, -1), (-1, -1)]:
        return 0

    opp_score_list = [4,3,2,1,2,3,4]

    if (-1, -1) in opponent_pos:
        opponent_pos.remove((-1, -1))
        opp_heu = 0
        for (row, col) in opponent_pos:
            opp_heu += opp_score_list[row] + opp_score_list[col]
        return opp_heu**2


    x1, x2, y1, y2 = 0, 0, 0, 0
    for idx, (row, col) in enumerate(opponent_pos):
        if (row, col) == (-1, -1): continue
        if idx == 0:
            x1, y1 = row, col
        else:
            x2, y2 = row, col

    opp_dist =  abs(x1 - x2) + abs(y1 - y2)

    return opp_dist

def position_heuristic(game, player):
    player_pos = game.get_player_position(player)
    opponent_pos = game.get_opponent_position(player)
    board_len = len(game.get_state())
    board_mid = board_len // 2
    #print(f"Board Length: {board_len}")

    player_pos_score = 0
    opponent_pos_score = 0
    score_list = [1,2,3,4,3,2,1]
    #print(f"Score List: {score_list}")
    for (row, col) in player_pos:
        if (row, col) == (-1, -1): continue
        player_pos_score -= (abs(row - board_mid)) + (abs(col - board_mid))
    for (row, col) in opponent_pos:
        if (row, col) == (-1, -1): continue
        opponent_pos_score += (abs(row - board_mid)) + (abs(col - board_mid))
    pos_heu = player_pos_score + opponent_pos_score
    return pos_heu

def mobility_heuristic(game, player):
    player_pos = game.get_player_position(player)
    opponent_pos = game.get_opponent_position(player)

    player_mobility_score = 0
    opponent_mobility_score = 0

    for (row, col) in player_pos:
        if (row, col) == (-1, -1): continue
        inc_row = row+1
        while game.move_is_in_board(inc_row, col) and \
            game.is_spot_open(inc_row, col) and \
            not game.is_spot_rook(inc_row, col):

            player_mobility_score += 1
            inc_row += 1

        dec_row = row-1
        while game.move_is_in_board(dec_row, col) and \
            game.is_spot_open(dec_row, col) and \
            not game.is_spot_rook(dec_row, col):

            player_mobility_score += 1
            dec_row -= 1

        inc_col = col+1
        while game.move_is_in_board(row, inc_col) and \
            game.is_spot_open(row, inc_col) and \
            not game.is_spot_rook(row, inc_col):

            player_mobility_score += 1
            inc_col += 1

        dec_col = col-1
        while game.move_is_in_board(row, dec_col) and \
            game.is_spot_open(row, dec_col) and \
            not game.is_spot_rook(row, dec_col):

            player_mobility_score += 1
            dec_col -= 1

    for (row, col) in opponent_pos:
        if (row, col) == (-1, -1): continue
        inc_row = row+1
        while game.move_is_in_board(inc_row, col) and \
            game.is_spot_open(inc_row, col) and \
            not game.is_spot_rook(inc_row, col):

            opponent_mobility_score += 1
            inc_row += 1

        dec_row = row-1
        while game.move_is_in_board(dec_row, col) and \
            game.is_spot_open(dec_row, col) and \
            not game.is_spot_rook(dec_row, col):

            opponent_mobility_score += 1
            dec_row -= 1

        inc_col = col+1
        while game.move_is_in_board(row, inc_col) and \
            game.is_spot_open(row, inc_col) and \
            not game.is_spot_rook(row, inc_col):

            opponent_mobility_score += 1
            inc_col += 1

        dec_col = col-1
        while game.move_is_in_board(row, dec_col) and \
            game.is_spot_open(row, dec_col) and \
            not game.is_spot_rook(row, dec_col):

            opponent_mobility_score += 1
            dec_col -= 1

    mobility_heu = player_mobility_score - opponent_mobility_score

    return mobility_heu

# def create_ascending_descending_list(x):
#     if x < 1:
#         return []
#     if x == 1:
#         return [1]
#     mid = (x+1) // 2
#     ascending_part = list(range(1, mid + 1))
#     descending_part = ascending_part[:-1] #if x % 2 == 0 #else ascending_part[:-1]
#     return ascending_part + descending_part[::-1]


def get_valid_moves(game, player):
    return game.get_player_moves(player)

def get_reflect_board_key(game, depth_left, min_or_max):
    board = game.get_state()
    board_len = len(board)

    board_orientations = []

    og_board_key = tuple("".join(row) for row in board)
    board_orientations.append(og_board_key)
    horizontal_board_key = tuple(row[::-1] for row in og_board_key)
    board_orientations.append(horizontal_board_key)
    vertical_board_key = tuple(og_board_key[board_len-1-i] for i in range(board_len))
    board_orientations.append(vertical_board_key)
    vertical_horizontal_board_key = tuple(row[::-1] for row in vertical_board_key)
    board_orientations.append(vertical_horizontal_board_key)

    #print(f" BOARD OREINTATIONS: {board_orientations}")


    min_board_key = min(og_board_key, horizontal_board_key, vertical_board_key, vertical_horizontal_board_key)

    return (min_board_key, depth_left, min_or_max)

######################################################################
########## DON'T WRITE ANY CODE OUTSIDE THE FUNCTION! ################͏︍͏︆͏󠄁
######## IF YOU WANT TO CALL OR TEST IT CREATE A NEW CELL ############͏︍͏︆͏󠄁
######################################################################
##### CODE BELOW IS USED FOR RUNNING LOCAL TEST DON'T MODIFY IT ######͏︍͏︆͏󠄁
################ END OF LOCAL TEST CODE SECTION ######################͏︍͏︆͏󠄁

class CustomEvalFn:
    def __init__(self):
        pass

    def score(self, game, my_player=None):
        """Score the current game state.

        Custom evaluation function that acts however you think it should. This
        is not required but highly encouraged if you want to build the best
        AI possible.

        Args:
            game (Board): The board and game state.
            my_player (Player object): This specifies which player you are.

        Returns:
            float: The current state's score, based on your own heuristic.
        """

        # TODO: finish this function!͏︍͏︆͏󠄁


        raise NotImplementedError

######################################################################
############ DON'T WRITE ANY CODE OUTSIDE THE CLASS! #################͏︍͏︆͏󠄁
######## IF YOU WANT TO CALL OR TEST IT CREATE A NEW CELL ############͏︍͏︆͏󠄁
######################################################################